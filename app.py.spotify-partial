# app.py

import os
import google.generativeai as genai
from flask import Flask, render_template, request, jsonify
from dotenv import load_dotenv
import traceback

# --- Spotify Imports ---
import spotipy
from spotipy.oauth2 import SpotifyClientCredentials
# --- End Spotify Imports ---

# --- Librosa/Audio Imports ---
import librosa
import numpy as np
import requests as req_lib # Using an alias to avoid conflict with flask.request
import io
# --- End Librosa/Audio Imports ---

load_dotenv() # Load environment variables from .env
app = Flask(__name__)

# --- Gemini API Configuration ---
try:
    gemini_api_key = os.environ.get("GEMINI_API_KEY")
    if not gemini_api_key:
        print("ERROR: GEMINI_API_KEY not found in environment variables. Text-based AI features will be disabled.")
        gemini_llm = None
    else:
        genai.configure(api_key=gemini_api_key)
        gemini_model_name = 'models/gemini-2.0-flash' # Your chosen Gemini model
        gemini_llm = genai.GenerativeModel(gemini_model_name)
        print(f"Gemini API configured successfully with model: {gemini_model_name}")
except Exception as e:
    print(f"FATAL ERROR configuring Gemini: {e}")
    traceback.print_exc()
    gemini_llm = None
# --- End Gemini Config ---

# --- Spotify API Configuration ---
try:
    spotify_client_id = os.environ.get("SPOTIPY_CLIENT_ID")
    spotify_client_secret = os.environ.get("SPOTIPY_CLIENT_SECRET")
    if spotify_client_id and spotify_client_secret:
        client_credentials_manager = SpotifyClientCredentials(client_id=spotify_client_id, client_secret=spotify_client_secret)
        sp = spotipy.Spotify(client_credentials_manager=client_credentials_manager)
        print("Spotify API configured successfully.")
    else:
        sp = None
        print("WARNING: Spotify API credentials (SPOTIPY_CLIENT_ID or SPOTIPY_CLIENT_SECRET) not found. Streaming search will be disabled.")
except Exception as e:
    sp = None
    print(f"Error configuring Spotify API: {e}")
    traceback.print_exc()
# --- End Spotify Config ---

# --- Text-based Genre Identification Function ---
def get_music_genre(song_title, artist_name):
    if not gemini_llm:
        print("DEBUG: get_music_genre called but gemini_llm is not initialized.")
        return "Error: Text-based genre API not configured. Check server logs."
    if not song_title or not artist_name:
        return "Please provide both song title and artist name."

    prompt = f"""
    You are a music expert specializing in genre identification.
    For the song "{song_title}" by artist "{artist_name}", identify its specific music genre and sub-genre.
    Provide a concise and accurate answer.
    Examples of desired output format:
    - Tropical Progressive House
    - Dark Moody Dubstep
    - Tech House
    - Progressive Rock

    If you are unsure about a very specific sub-genre, try to provide the closest broader genre.
    For example, if you can't pinpoint "Melodic Progressive House", "Progressive House" or even "House" would be acceptable.
    If the track is extremely obscure and you have no confident genre, then you can state "Could not confidently determine genre."
    Do not add any conversational fluff, just the genre.

    Song: "{song_title}"
    Artist: "{artist_name}"
    Identified Genre:
    """
    try:
        print(f"DEBUG: Sending text prompt to Gemini for: Song='{song_title}', Artist='{artist_name}'")
        response = gemini_llm.generate_content(prompt)
        
        genre_text = ""
        if hasattr(response, 'text') and response.text:
            genre_text = response.text
        elif response.candidates and \
             response.candidates[0].content and \
             response.candidates[0].content.parts and \
             response.candidates[0].content.parts[0].text:
            genre_text = response.candidates[0].content.parts[0].text
        else:
            print(f"DEBUG: Could not extract text using common attributes. Full response: {response}")
            if hasattr(response, 'prompt_feedback') and response.prompt_feedback and response.prompt_feedback.block_reason:
                return f"Blocked by API (Text): {response.prompt_feedback.block_reason_message or response.prompt_feedback.block_reason}"
            return "Error: Failed to parse response from Gemini API (text). Check server logs."

        cleaned_genre = genre_text.strip().replace("*", "").replace("`", "")
        print(f"DEBUG (Gemini Text): Cleaned genre: '{cleaned_genre}'")

        if not cleaned_genre:
            return "Could not determine genre (API returned empty or only formatting characters)."
        return cleaned_genre
    except Exception as e:
        print(f"ERROR in get_music_genre for '{song_title}' by '{artist_name}': {e}")
        traceback.print_exc()
        return f"Error communicating with Gemini API (text). (Details: {str(e)})"
# --- End Text-based Genre Identification ---

# --- Audio Feature Extraction and Description ---
def describe_audio_features(y, sr):
    description_parts = []
    try:
        tempo, _ = librosa.beat.beat_track(y=y, sr=sr)
        description_parts.append(f"Estimated tempo: {tempo:.2f} BPM.")
    except Exception as e: print(f"Librosa Error (tempo): {e}")
    try:
        mfccs = librosa.feature.mfcc(y=y, sr=sr, n_mfcc=13)
        mfccs_mean = np.mean(mfccs, axis=1)
        description_parts.append(f"MFCCs means (first 3 of 13): {mfccs_mean[:3].round(2).tolist()}.")
    except Exception as e: print(f"Librosa Error (MFCCs): {e}")
    try:
        cent = librosa.feature.spectral_centroid(y=y, sr=sr)
        description_parts.append(f"Average spectral centroid (brightness indicator): {np.mean(cent):.2f}.")
    except Exception as e: print(f"Librosa Error (spectral_centroid): {e}")
    try:
        zcr = librosa.feature.zero_crossing_rate(y)
        description_parts.append(f"Average zero-crossing rate (percussiveness/noisiness indicator): {np.mean(zcr):.4f}.")
    except Exception as e: print(f"Librosa Error (ZCR): {e}")

    if not description_parts: return "Could not extract significant audio features."
    return " ".join(description_parts)
# --- End Audio Feature Extraction ---

# --- Flask Routes ---
@app.route('/', methods=['GET', 'POST'])
def index():
    genre_result = None
    song_title_input = ""
    artist_name_input = ""

    if request.method == 'POST':
        song_title_input = request.form.get('song_title', '').strip()
        artist_name_input = request.form.get('artist_name', '').strip()
        
        if not gemini_llm:
            genre_result = "Error: Text-based genre API not configured. Check server logs."
        elif not song_title_input or not artist_name_input:
            genre_result = "Please provide both song title and artist name for text-based search."
        else:
            genre_result = get_music_genre(song_title_input, artist_name_input)

    return render_template('index.html',
                           genre_result=genre_result,
                           song_title_input=song_title_input,
                           artist_name_input=artist_name_input)

@app.route('/search_streaming', methods=['POST'])
def search_streaming():
    if not sp: # Check if Spotify client (sp) is initialized
        return jsonify({"error": "Streaming search not available (Spotify API not configured or failed to init)"}), 503

    data = request.get_json()
    song_title = data.get('song_title')
    artist_name = data.get('artist_name')

    if not song_title or not artist_name:
        return jsonify({"error": "Song title and artist name are required for streaming search"}), 400

    query = f"track:{song_title} artist:{artist_name}"
    try:
        print(f"DEBUG: Searching Spotify with query: {query}")
        results = sp.search(q=query, type='track', limit=10)
        
        # --- Optional: Uncomment for one test run to see raw Spotify response ---
        # print(f"DEBUG: Raw Spotify results: {results}") 
        # --- End optional raw results print ---

        tracks = []
        # More robust checks for the existence of keys in the Spotify response
        if results and isinstance(results.get('tracks'), dict) and isinstance(results['tracks'].get('items'), list):
            for item in results['tracks']['items']:
                if item and isinstance(item, dict) and item.get('preview_url'): 
                    track_data = {
                        'id': item.get('id'),
                        'name': item.get('name'),
                        'preview_url': item.get('preview_url'),
                        'artist': "Unknown Artist", # Default value
                        'album': "Unknown Album",   # Default value
                        'image_url': None           # Default value
                    }
                    
                    if isinstance(item.get('artists'), list) and item['artists']:
                        track_data['artist'] = ", ".join([artist.get('name', '') for artist in item['artists'] if artist.get('name')])
                    
                    album_info = item.get('album')
                    if isinstance(album_info, dict):
                        track_data['album'] = album_info.get('name', 'Unknown Album')
                        if isinstance(album_info.get('images'), list) and album_info['images']:
                            track_data['image_url'] = album_info['images'][0].get('url')
                    
                    tracks.append(track_data)
        else:
            print("DEBUG: Spotify search returned no items or unexpected structure.")
            if results: # Log what was received if it's not the expected structure
                print(f"DEBUG: Spotify 'results' object structure was: {results}")

        print(f"DEBUG: Found {len(tracks)} tracks with previews on Spotify.")
        return jsonify(tracks)
        
    except spotipy.SpotifyException as e: # Catch specific Spotipy exceptions
        print(f"SPOTIPY ERROR during Spotify search: {e}")
        # These attributes might exist on the exception object
        http_status = getattr(e, 'http_status', 500) 
        reason = getattr(e, 'reason', getattr(e, 'msg', "Unknown Spotify Error"))
        print(f"Spotipy HTTP Status: {http_status}")
        print(f"Spotipy Error Code: {getattr(e, 'code', 'N/A')}") # code might not always be present
        print(f"Spotipy Error Reason: {reason}")
        traceback.print_exc()
        return jsonify({"error": f"Spotify API Error: {reason}"}), http_status
    except Exception as e:
        print(f"GENERAL ERROR during Spotify search: {e}")
        traceback.print_exc()
        return jsonify({"error": f"An unexpected error occurred during Spotify search: {str(e)}"}), 500

@app.route('/analyze_audio_genre', methods=['POST'])
def analyze_audio_genre():
    if not gemini_llm:
        return jsonify({"error": "Genre analysis not available (Gemini API for audio not configured)"}), 503

    data = request.get_json()
    preview_url = data.get('preview_url')
    song_title_for_prompt = data.get('song_title', 'the provided audio clip') 
    artist_name_for_prompt = data.get('artist_name', 'the artist')

    if not preview_url:
        return jsonify({"error": "Preview URL is required"}), 400
    
    try:
        print(f"DEBUG: Downloading audio from {preview_url}")
        audio_response = req_lib.get(preview_url, timeout=15) 
        audio_response.raise_for_status()
        
        audio_stream = io.BytesIO(audio_response.content)
        y, sr = librosa.load(audio_stream, duration=30) 
        print(f"DEBUG: Audio loaded. Duration: {librosa.get_duration(y=y, sr=sr):.2f}s, SR: {sr}Hz")

        feature_description = describe_audio_features(y, sr)
        print(f"DEBUG: Audio feature description: {feature_description}")

        if "Could not extract significant audio features" in feature_description:
            return jsonify({"genre_by_audio": "Could not analyze audio effectively (feature extraction failed).", "preview_url": preview_url}), 200

        audio_prompt = f"""
        You are a music expert specializing in genre identification from audio features.
        Based on the following description of audio features for the song "{song_title_for_prompt}" by "{artist_name_for_prompt}", identify its specific music genre and sub-genre.
        Provide a concise and accurate answer. Be specific with sub-genres if possible.
        Examples of desired output format:
        - Tropical Progressive House
        - Dark Moody Dubstep
        - Melodic Techno
        - Liquid Drum and Bass
        - Classic Rock (based on features)
        - Psychedelic Trance (based on features)

        Audio Feature Description:
        "{feature_description}"

        If the features are too generic or insufficient for a specific sub-genre, try to provide the closest broader genre.
        If highly uncertain, state "Could not confidently determine genre from audio features."
        Do not add any conversational fluff, just the genre.

        Identified Genre from Audio:
        """
        
        print("DEBUG: Sending audio feature prompt to Gemini.")
        gemini_response = gemini_llm.generate_content(audio_prompt)
        
        genre_text_audio = ""
        if hasattr(gemini_response, 'text') and gemini_response.text:
            genre_text_audio = gemini_response.text
        elif gemini_response.candidates and \
             gemini_response.candidates[0].content and \
             gemini_response.candidates[0].content.parts and \
             gemini_response.candidates[0].content.parts[0].text:
            genre_text_audio = gemini_response.candidates[0].content.parts[0].text
        else:
            print(f"DEBUG: Could not extract audio genre text using common attributes. Full response: {gemini_response}")
            if hasattr(gemini_response, 'prompt_feedback') and gemini_response.prompt_feedback and gemini_response.prompt_feedback.block_reason:
                return jsonify({"genre_by_audio": f"Blocked by API (Audio): {gemini_response.prompt_feedback.block_reason_message or gemini_response.prompt_feedback.block_reason}", "preview_url": preview_url})
            return jsonify({"genre_by_audio": "Error: Failed to parse response from Gemini API (audio).", "preview_url": preview_url})

        cleaned_genre_audio = genre_text_audio.strip().replace("*", "").replace("`", "")
        print(f"DEBUG (Audio Gemini): Cleaned genre: '{cleaned_genre_audio}'")

        if not cleaned_genre_audio:
            return jsonify({"genre_by_audio": "Could not determine genre from audio (API returned empty).", "preview_url": preview_url})
        
        return jsonify({"genre_by_audio": cleaned_genre_audio, "preview_url": preview_url})

    except req_lib.exceptions.RequestException as e:
        print(f"Error downloading audio: {e}")
        return jsonify({"error": f"Failed to download audio preview: {str(e)}"}), 500
    except librosa.LibrosaError as e:
        print(f"Librosa error during audio processing: {e}")
        traceback.print_exc()
        return jsonify({"error": f"Audio processing error (librosa): {str(e)}"}), 500
    except Exception as e:
        print(f"Error during audio analysis: {e}")
        traceback.print_exc()
        return jsonify({"error": f"An unexpected error occurred during audio analysis: {str(e)}"}), 500
# --- End Flask Routes ---

if __name__ == '__main__':
    app.run(debug=True, host='0.0.0.0', port=5000)
